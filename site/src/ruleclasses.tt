<!DOCTYPE html>
<html>
  [%- PROCESS config.tt -%]
  [%- title = "About Rule Classes" -%]  
  [%- INCLUDE header.tt -%]

[%

%]
  
  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
      <header class="inner">
          <h1 id="project_title">[% title %]</h1>
      </header>
      [%- INCLUDE nav.tt -%]
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="toc" class="inner">
  	    [% PROCESS rc.tt %]

		<ul>
			<li><a href='#structures'>Structures</a></li>
			<ul>
				<li><a href='#grd'>Graph of rule dependencies</a></li>
				<li><a href='#gp'>Graph of position dependencies</a></li>
				<li><a href='#marked'>Marked variable set</a></li>
				<li><a href='#affected'>Affected position set</a></li>
			</ul>
			</li>
			<li><a href='#rc'>Rule classes</a>
			<ul>
				<li><a href='#abstract'>Abstract rule classes</a>
				<ul>
					[% FOR c IN rule_classes.abstract %]
					[% link = '#' _ c.label %]
						<li><a href='[% link %]'>[% c.name %]</a></li>
					[% END %]
				</ul>
				</li>
				<li><a href='#concrete'>Concrete rule classes</a>
				<ul>
					[% FOR c IN rule_classes.concrete %]
					[% link = '#' _ c.label %]
						<li><a href='[% link %]'>[% c.name %]</a></li>
					[% END %]
				</ul>
				</li>
			</ul>
			</li>
		</ul>
      </section>

 
      <section id="structures" class="inner">
        <a name="structures"></a>
		<h2>Structures</h2>
        <p>
          The following structures are used by the analyzer for checking some rule classes. 
		  Furthermore the graph of rule dependencies is also used in the
		  combination step to compute rule base subsets (corresponding to its strongly connected
		  components).
        </p>

		<a name="grd"></a>
        <h4>Graph of rule dependencies</h4>
		<p>
		  The graph of rule dependencies (GRD) is a directed graph built from a rule
		  set as follows:
		  there is a vertex for each rule in the set and there is an edge from a
		  rule R<sub>1</sub> to a rule R<sub>2</sub> if R<sub>1</sub> <i>may
			lead to trigger</i> R<sub>2</sub>, i.e., R<sub>2</sub> depends on R<sub>1</sub>.
		  R<sub>2</sub> depends on R<sub>1</sub> if and only if there is piece-unifier
		  (for this notion, see f.i. <a href="http://www.lirmm.fr/~mugnier/ArticlesPostscript/BLMSDecidabilityLine-PreAIJ2011.pdf">
			this paper</a>) <!--(without the <i>atom erasing</i> check) --> 
		  between the body of R<sub>2</sub> and the head of R<sub>1</sub>.
		</p>

		<a name="gpos"></a>
        <h4>Graph of Position Dependencies</h4>
		The graph of position dependencies noted G<sub>pos</sub> is a directed graph
		built from a rule set as follows:
		first, for each predicate p and for each of its positions p[i] a vertex is
		added. 
		Then, for each rule and for each variable x that occurs at some position p[i] in the rule
		body: (1) for each position r[j] where x also occurs in the rule head, a
		<i>normal</i> edge is added
		from p[i] to r[j], and (2) for each position q[k] in the rule head where some
		existentially quantified variable appears, a <i>special</i> edge is added 
		from p[i] to q[k].
		<p></p>
		<p>In this graph, a vertex (hence a predicate position) is of <i>finite
			rank</i> if there is no circuit containing a special edge and passing
		  through this vertex.
		</p>
		
		<a name="marked"></a>
        <h4>Marked Variable Set</h4>
		<p>
		  The marked variable set is built from a rule set by the 
		  following marking procedure:<br>
		  (i) for each rule R<sub>i</sub> and for each variable v occuring in 
		  its body, if v does not occur in all atoms of its head, mark (each occurrence of) v in its body;<br>
		  (ii) apply until a fixpoint is reached: for each rule R<sub>i</sub>, if a marked variable v appears at position p[k] in its body, 
		  then for each rule R<sub>j</sub> (including
		  i = j) and for each variable x appearing at position p[k] in the head of R<sub>j</sub>,
		  mark each occurence of x in the body of R<sub>j</sub>.
		</p>

		<a name="gpos"></a>
        <h4>Affected Position Set</h4>
		<p>
		  The affected position set is built from a rule set 
		  by the following procedure:<br>
		  (i) for each rule and for each existentially quantified variable occuring
		  at position p[i] in its head, p[i] is affected;<br>
		  (ii) for each rule and for each variable x that occurs <i>only</i>
		  at affected positions in its body, all positions q[j] in its head where occurs x are
		  affected.
		</p>
		<p>A variable is said to be <i>affected</i> if it occurs only at affected
		  positions.
		</p>
	  </section>

		<section id="rc" class="inner">
        <a name="rc"></a>
		<h2>Rule Classes</h2>

        <p>
		The rule classes are divided into two types: <i>abstract</i> classes, which ensure
		 decidability but are not recognizable, i.e., one cannot always determine if a set for rules belongs to such a class, 
		 and <i>concrete</i> classes, which may specialize one or
		several abstract classes and are recognizable by syntactic properties.
		</p>
		
		In the figure on the right side, rule classes are ordered by inclusion: 
		an edge between two classes means that the above one includes the one below.
		If there is no edge between two classes, it means there are incomparable.
		Note that a class was omitted in this picture for the sake of readability: 
		 <i>disconnected</i> rules, which are
		<i>fes</i>, <i>fus</i> and <i>gbts</i>, and are a specialization of
		<i>domain-restricted</i>, <i>weakly-acyclic</i> and <i>frontier-guarded</i>
		rules.
		<br>
		Finally, some classes present in this figure are not implemented for now in the
		analyzer, hence they are not described below. These classes are the following:
		<ul>
			<li>weakly-sticky-join (w-sticky-j)</li>
			<li>sticky-join (sticky-j)</li>
			<li>glut-frontier-guarded (glut-fg)</li>
			<li>jointly-frontier-guarded (j-fg)</li>
			<li>jointly-acyclic (ja).</li>
		</ul>

        <a name="abstract"></a>
		<h3>Abstract Rule Classes</h3>
		<p>
		These rule classes are said <em>abstract</em> because they
		have no syntactic property and are used to classify concrete
		classes. Each of these classes ensures the existence of
		query mechanisms that halt in finite time for any query.
		Determining if a rule (or a set of rules) belongs to one
		of these abstract classes is an undecidable problem.
		</p>

		[% FOR c IN rule_classes.abstract %]
            <a name="[% c.label %]"></a>
			<h4>[% c.name %] ([% c.label %])</h4>
			<p>[% c.description %]</p>
		[% END %]

	
        
        <a name="concrete"></a>
		<h3>Concrete Rule Classes</h3>
		<p>
		These classes are presented with their syntactic property
		and the abstract classes they belong to.
		</p>

		<p>
		There are two kinds of syntactic properties:
		<ul>
		<li><strong>local properties</strong> which are checked on
		each rule independently from the others (hence a set fulfils
		a local property if all of its rules fullfil it);</li>
		<li><strong>global properties</strong> which are checked on
		the set of rules (note that the analyser may <em>cut</em> the set
		into subsets of rules thanks to the <a href='#grd'>graph of
		rule dependencies</a> strongly connected components).
		</ul>
		</p>

		<p>
		Reminder: the <em>frontier</em> of a rule is the set of
		variables shared by its body and its head.
		<p>

		[% FOR c IN rule_classes.concrete %]
            <a name="[% c.label %]"></a>
			<h4>[% c.name %] ([% c.label %])</h4>
			[% IF c.type == 'link' %]
				[% l = '#' _ c.link_label %]
				See <a ref='[% l %]'>[% c.link_name %]</a>.
			[% ELSE %]
				<p>This rule class property is a [% c.type %] property.<br/>
				Ensures:
				<ul>
					[% FOR c2 IN c.ensures %]
						<li>[% c2 %]</li>
					[% END %]
				</ul>
				</p>
				<p>[% c.description %]</p>
			[% END %]
		[% END %]
	    </section>

    </div>


    [%- INCLUDE footer.tt -%]

  </body>
</html>
